package org.vadere.gui.postvisualization;

import net.sourceforge.argparse4j.ArgumentParsers;
import net.sourceforge.argparse4j.inf.*;

import javax.imageio.ImageIO;

import org.vadere.gui.postvisualization.model.PostvisualizationModel;
import org.vadere.gui.postvisualization.utils.ImageGenerator;
import org.vadere.gui.postvisualization.utils.SVGGenerator;
import org.vadere.gui.postvisualization.view.PostvisualizationRenderer;
import org.vadere.simulator.projects.io.IOOutput;
import org.vadere.simulator.projects.io.TrajectoryReader;
import org.vadere.util.io.IOUtils;

import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Locale;
import java.util.Optional;

/**
 * Provides the possibility to generate a picture based on a output-file in console mode.
 * 
 */
public class PostVisualizationConsole {

	public static void main(final String... args) {
		ArgumentParser parser = ArgumentParsers.newArgumentParser("prog")
				.defaultHelp(true)
				.description("Runs the VADERE Postvisualization for image generation.");
		parser.addArgument("-out", "--outputFile").required(true)
				.help("Path to target file, where the snapshot will be saved.");
		parser.addArgument("-in", "--inputDirectory").required(true)
				.help("Path to the input directory, the output-directory that was generated by the VADERE simulation.");
		parser.addArgument("-r", "--resolution").type(Double.class).required(true).help("Resolution of the snapshot.");

		ArgumentGroup groupViewport = parser.addArgumentGroup("group");

		groupViewport.addArgument("-x", "--xStart").type(Double.class).setDefault(0.0).required(false)
				.help("X-Position in world coordinates of the viewport of the snapshot.");
		groupViewport.addArgument("-y", "--yStart").type(Double.class).setDefault(0.0).required(false)
				.help("Y-Position in wolrd coordinates of the viewport of the snapshot.");

		groupViewport.addArgument("-width", "--width").type(Double.class).setDefault(-1.0).required(false)
				.help("Width in wolrd coordinates of the viewport of the snapshot.");
		groupViewport.addArgument("-height", "--height").type(Double.class).setDefault(-1.0).required(false)
				.help("Height in wolrd coordinates of the viewport of the snapshot.");

		MutuallyExclusiveGroup group = parser.addMutuallyExclusiveGroup("group").required(true);
		group.addArgument("-s", "--step").type(Integer.class).setDefault(-1).help("Step number of the snapshot.");
		group.addArgument("-t", "--time").type(Double.class).setDefault(0.0).help("Time in seconds of the snapshot.");

		Namespace ns = null;
		try {
			ns = parser.parseArgs(args);
		} catch (ArgumentParserException e) {
			parser.handleError(e);
			System.exit(1);
		}

		Locale.setDefault(Locale.ENGLISH);
		String outputDirectoryPath = Paths.get(ns.getString("inputDirectory")).toString();
		String snapshotFile = Paths.get(ns.getString("outputFile")).toString();
		Integer step = ns.getInt("step");
		Double time = ns.getDouble("time");
		Double x = ns.getDouble("xStart");
		Double y = ns.getDouble("yStart");
		Double width = ns.getDouble("width");
		Double height = ns.getDouble("height");
		Double resolution = ns.getDouble("resolution");

		PostvisualizationModel model = new PostvisualizationModel();
		PostvisualizationRenderer renderer = new PostvisualizationRenderer(model);



		/*
		 * Set all necessary data to the model (topography, viewport, scaleFactor, time or step).
		 */
		Path path = Paths.get(outputDirectoryPath);

		try {
			Optional<File> trajectoryFile = IOUtils.getFirstFile(path.toFile(), IOUtils.TRAJECTORY_FILE_EXTENSION);
			Optional<File> scenarioFile = IOUtils.getFirstFile(path.toFile(), IOUtils.SCENARIO_FILE_EXTENSION);

			if (trajectoryFile.isPresent() && scenarioFile.isPresent()) {
				TrajectoryReader reader = new TrajectoryReader(trajectoryFile.get().toPath());
				model.init(reader.readFile(), IOOutput.readScenario(scenarioFile.get().toPath()), trajectoryFile.get().getParent());
			} else {
				System.err.println("could not find trajectory or scenario file in: " + outputDirectoryPath);
			}

		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}

		if (width < 0) {
			width = model.getTopographyBound().getWidth();
		}

		if (height < 0) {
			height = model.getTopographyBound().getHeight();
		}
		model.setViewportBound(new Rectangle2D.Double(x, y, width, height));
		model.setScale(1.0 / resolution);

		if (step != -1) {
			model.setStep(step);
		} else {
			model.setTime(time);
		}


		/*
		 * generate a picture (svg or png) based on the model state.
		 */
		if (snapshotFile.endsWith("svg")) {
			SVGGenerator svgGenerator = new SVGGenerator(renderer, renderer.getModel());
			svgGenerator.generateSVG(new File(snapshotFile));
		} else {
			ImageGenerator pngGenerator = new ImageGenerator(renderer, renderer.getModel());
			BufferedImage bi = pngGenerator.generateImage();

			try {
				ImageIO.write(bi, "png", new File(snapshotFile));
			} catch (IOException e) {
				e.printStackTrace();
				System.exit(1);
			}
		}
	}
}
